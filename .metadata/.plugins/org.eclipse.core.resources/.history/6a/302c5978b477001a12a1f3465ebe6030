package br.com.cast.evaluation.service;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import br.com.cast.evaluation.exception.CourseNotFoundException;
import br.com.cast.evaluation.exception.InitialDateInvalidException;
import br.com.cast.evaluation.exception.UsedPeriodException;
import br.com.cast.evaluation.model.Category;
import br.com.cast.evaluation.model.Course;
import br.com.cast.evaluation.payload.CoursePayload;
import br.com.cast.evaluation.repository.CourseRepository;
import br.com.cast.evaluation.response.CourseResponse;

@Service
public class CourseService {

	@Autowired
	private CourseRepository courseRepository;
	

	public CourseResponse saveCourse(CoursePayload payload) {
		
		validationCourses(payload);
		
		return getCourseResponse(courseRepository.save(getCourse(payload)));
	}
	
	public CourseResponse updateCourse(CoursePayload payload, Long courseId) {
		
		validationCourses(payload);
		
		Course entity = getCourseById(courseId);
		payload.setId(entity.getId());
		return saveCourse(payload);		
	}
	
	public void deleteCourse(Long courseId) {
		
		 courseRepository.delete(getCourseById(courseId));
	}
	
	public List<CourseResponse> getAllCourses(){
		
		return StreamSupport.stream(courseRepository.findAll().spliterator(), false)
				.map(this::getCourseResponse)
	    		.collect(Collectors.toList());
	}
	
	private void validationCourses(CoursePayload payload) {
		
		if(payload.getInitialDate().isBefore(LocalDate.now())) {
			throw new InitialDateInvalidException();
		}
		
		List<Course> listCourse = courseRepository.findByInitialDateGreaterThanEqualAndFinalDateLessThanEqual(
					payload.getInitialDate(), payload.getFinalDate());
		
		if(!listCourse.isEmpty()) {
			throw new UsedPeriodException();
		}
	}
	
	
	private Course getCourseById(Long courseId){
		
		Optional<Course> course = courseRepository.findById(courseId);
		
		if(course.isPresent()) {
			return course.get();
		}else {
			throw new CourseNotFoundException();
		}
	}
	
	
	private Course getCourse(CoursePayload payload) {
		
		return Course.builder()
				  .id(payload.getId())
				  .descriptionSubject(payload.getDescriptionSubject())
				  .initialDate(payload.getInitialDate())
				  .finalDate(payload.getFinalDate())
				  .numberStudents(payload.getNumberStudents())
				  .category(Category.builder()
						  .id(payload.getId())
						  .description(payload.getDescriptionSubject())
						  .build())
				  .build();
	}
	
	private CourseResponse getCourseResponse(Course course) {
		
		return CourseResponse.builder()
				  .id(course.getId())
				  .descriptionSubject(course.getDescriptionSubject())
				  .initialDate(course.getInitialDate())
				  .finalDate(course.getFinalDate())
				  .numberStudents(course.getNumberStudents())
				  .category(course.getCategory()).build();
	}
}
